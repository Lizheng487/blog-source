---
title: 自定义懒加载指令+三种滚动加载效果
code_block_shrink: false
date: 2025-07-08 14:39:44
tags:
categories:
sticky:
---

- 传统 scroll 事件
- scroll 事件 + 节流 + requestAnimationFrame 优化
- IntersectionObserver 观察者模式
- 自定义懒加载指令

<!-- more -->

## 三种滚动加载效果

### 传统 scroll 事件

- 原理：监听页面滚动事件，分析 clientHeight,scrollTop,scrollHeight 关系
- 1.  scrollTop -- 滚动条距离顶部的高度
- 2.  scrollHeight -- 当前页面的总高度(body 总高度)
- 3.  clientHeight -- 当前可视的页面高度(设备窗口的高度)

```javascript
window.addEventListener(
  "scroll",
  function () {
    // 获取视口的高度。window.innerHeight || Math.min(document.documentElement.clientHeight, document.body.clientHeight);
    const clientHeight = document.documentElement.clientHeight;
    // 获取滚动条的垂直位置。window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    const scrollTop = document.documentElement.scrollTop;
    // 获取文档的总高度。Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
    const scrollHeight = document.documentElement.scrollHeight;
    // 检查是否滚动到底部
    if (clientHeight + scrollTop >= scrollHeight) {
      // 监测到滚动到底部，进行后续操作
    }
  },
  false
);
```

### scroll 事件 + 节流 + requestAnimationFrame 优化

- 在传统的滚动监听中，每次滚动都会触发 scroll 事件，可能会导致性能问题。为了解决这个问题，我们可以使用节流（throttle）来限制触发频率。
- 使用 requestAnimationFrame 浏览器会自动优化动画，从而提高性能。

```javascript
let isScrolling = false;

window.addEventListener("scroll", () => {
  if (!isScrolling) {
    isScrolling = true;
    requestAnimationFrame(function () {
      const clientHeight = document.documentElement.clientHeight;
      const scrollTop = document.documentElement.scrollTop;
      const scrollHeight = document.documentElement.scrollHeight;
      if (clientHeight + scrollTop >= scrollHeight) {
        console.log("滚动到底部了，可以加载更多内容");
        // 在这里调用加载更多内容的函数
      }
      isScrolling = false;
    });
  }
});
```

### IntersectionObserver 观察者模式

- IntersectionObserver 是一种用于监听元素是否进入或离开可视区域的 API，它可以实现懒加载。

```javascript
function handleIntersection(entries, observer) {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      loadMoreData().then((newData) => {
        console.log("loadMoreData:", newData);
        // 重新观察加载提示
        observer.observe(document.getElementById("loader"));
      });
    }
  });
}

const observer = new IntersectionObserver(handleIntersection, {
  threshold: 0.1, // 当加载提示进入视口 10% 时触发
});

// 开始观察加载提示
observer.observe(document.getElementById("loader"));
```

## 自定义懒加载指令

定义了一个自定义指令 v-lazy，用于懒加载图片。

```javascript
// 自定义指令，懒加载
app.directive("lazy", {
  mounted(el, binding) {
    const observe = new IntersectionObserver(
      ([{ isIntersecting }]) => {
        if (isIntersecting) {
          observe.unobserve(el);
          el.onerror = () => {
            el.src = defaultImg;
          };
          el.src = binding.value;
        }
      },
      {
        threshold: 0,
      }
    );
    observe.observe(el);
  },
});
```
